#include "pico/stdlib.h"
#include "pico/binary_info.h"
#include "oled_sh1122.hh"

OLED::OLED(SPI &spi) : m_spi(spi),
                       m_brightness(0x80)
{
}

OLED::~OLED()
{
}

void OLED::init()
{
    gpio_init(PIN_OLED_DC);
    gpio_set_dir(PIN_OLED_DC, GPIO_OUT);
    gpio_pull_up(PIN_OLED_DC);
    gpio_put(PIN_OLED_DC, 1);

    // VCC Generated by Internal DC/DC Circuit
    Set_Display_On_Off(0xAE);              // Display Off (0xAE/0xAF)
    Set_Start_Line(0x20);                  // Set Display Start Line (0x00~0x7F)
    Set_Contrast_Control(m_brightness);    // Set Scale Factor of Segment Output Current Control
    Set_Remap_Format(0x01);                // Set segment re-map   The right (0) or left(1) rotation
    Set_Entire_Display_OFF_On(0x00);       // 0x00= normal display ; 0x01=Entire Display ON
    Set_Display_Mode(0x00);                // 0x00= normal display; 0x01=reverse display
    Set_Multiplex_Ratio(0x3F);             // 1/64 Duty (0x0F~0x3F)
    Set_DC_DC_Control(0x80);               // control the DC-DC voltage and the switch frequency
    Set_Row_Address_Set(0x00);             // Row Address Set
    Set_Common_Output_ScanDirection(0xC8); // C0= scan from COM0 to COM[N-1}; C8=scan From COM[N-1] to COM0
    Set_Display_Offset(0x00);              // Set Offset Data
    Set_Display_Clock(0x90);               // Set Clock as 80 Frames/Sec
    Set_Precharge_Period(0x76);            // Set Dis-Charge/Pre-Charge Period
    Set_VCOMH(0x3B);                       // Set VCOM Deselect Level Data
    Set_VSEGM_Level(0x1a);                 // Set the segment pad output voltage level at pre-charge stage
    Set_Discharge_Voltage_VSL(0x30);       // Set the discharge voltage level

    Fill_RAM(0x00);				           // Clear Screen

    Set_Display_On_Off(0xAF);              // Display On (0xAE/0xAF)
}

// 4-wire Serial
void OLED::Write_Command(uint8_t Data)
{
    gpio_put(PIN_OLED_DC, 0);

    int r = spi_write_blocking(spi0, &Data, 1);

    gpio_put(PIN_OLED_DC, 1);

    /*
        uint8_t i;
        CS=0;
        DC=0;
        for (i=0; i<8; i++)
        {
            SCLK=0;
            SDIN=(Data&0x80)>>7;
            Data = Data << 1;
    //		uDelay(1);
            SCLK=1;
    //		uDelay(1);
        }
    //	SCLK=0;
        DC=1;
        CS=1;
        */
}

void OLED::Write_Data(uint8_t Data)
{
    gpio_put(PIN_OLED_DC, 1);

    int r = spi_write_blocking(spi0, &Data, 1);

    /*
    uint8_t i;

    CS=0;
    DC=1;
    for (i=0; i<8; i++)
    {
        SCLK=0;
        SDIN=(Data&0x80)>>7;
        Data = Data << 1;
//		uDelay(1);
        SCLK=1;
//		uDelay(1);
    }
//	SCLK=0;
    DC=1;
    CS=1;
    */
}

void OLED::Set_Column_Address(uint8_t a, uint8_t b)
{
    Write_Command(a); // Set higher column Address
    Write_Command(b); // Set lower Column Address
}

void OLED::Set_Row_Address(uint8_t d)
{
    Write_Command(0xB0); // Set Row Address
    Write_Command(d);    // Set column Address
}

void OLED::Set_Start_Line(uint8_t d)
{
    Write_Command(0x40 | d); // Set  Display strat line
}

void OLED::Set_Contrast_Control(uint8_t d)
{
    Write_Command(0x81); // Set contrast control
    Write_Command(d);    //   Default => 0x80 (Maximum)
}

void OLED::Set_Remap_Format(uint8_t d)
{
    Write_Command(0xA0 | d); // Set segment Re-Map
}

void OLED::Set_Entire_Display_OFF_On(uint8_t d)
{
    Write_Command(0xA4 | d); // 0x00 Set normal  display ; 0x01 Set Display On
}

void OLED::Set_Display_Mode(uint8_t d)
{
    Write_Command(0xA6 | d); // 0x00 = normal display;0x01 = Reverse display
}

void OLED::Set_Multiplex_Ratio(uint8_t d)
{
    Write_Command(0xA8); // Set Multiplex Ratio	  from 1 to 64
    Write_Command(d);    //   Default => 0x3F
}

void OLED::Set_DC_DC_Control(uint8_t d)
{
    Write_Command(0xAD); //
    Write_Command(d);    //
}

void OLED::Set_Display_On_Off(uint8_t d)
{
    Write_Command(d); // Set Display On/Off
                      //   Default => 0xAE
}

void OLED::Set_Row_Address_Set(uint8_t d)
{
    Write_Command(0xB0); // Default ==> 0x00
    Write_Command(d);
}

void OLED::Set_Common_Output_ScanDirection(uint8_t d)
{
    Write_Command(d); // Default ==> 0xC0
}

void OLED::Set_Display_Offset(uint8_t d)
{
    Write_Command(0xD3);
    Write_Command(d); // Default ==>0x00
}

void OLED::Set_Display_Clock(uint8_t d)
{
    Write_Command(0xD5); // Set Display Clock Divider / Oscillator Frequency
    Write_Command(d);    //   Default => 0x50
}

void OLED::Set_Precharge_Period(uint8_t d)
{
    Write_Command(0xD9); // Set Second Pre-Charge Period
    Write_Command(d);    //   Default => 0x08 (8 Display Clocks)
}

void OLED::Set_VCOMH(uint8_t d)
{
    Write_Command(0xDB); // Set COM Deselect Voltage Level
    Write_Command(d);    //   Default => 0x35
}

void OLED::Set_VSEGM_Level(uint8_t d)
{
    Write_Command(0xDC);
    Write_Command(d); // Default ==>0x35
}

void OLED::Set_Discharge_Voltage_VSL(uint8_t d)
{
    Write_Command(d); //
}

void OLED::Set_Partial_Display(uint8_t a, uint8_t b, uint8_t c)
{
    Write_Command(0xA8 | a);

    if (a == 0x00)
    {
        Write_Command(b);
        Write_Command(c);
    }
}

void OLED::Data_processing(unsigned char temp) // turns 1byte B/W data to 4 byte gray data
{
    unsigned char temp1, temp2, temp3, temp4, temp5, temp6, temp7, temp8;
    unsigned char h11, h12, h13, h14, h15, h16, h17, h18, d1, d2, d3, d4;

    temp1 = temp & 0x80;
    temp2 = (temp & 0x40) >> 3;
    temp3 = (temp & 0x20) << 2;
    temp4 = (temp & 0x10) >> 1;
    temp5 = (temp & 0x08) << 4;
    temp6 = (temp & 0x04) << 1;
    temp7 = (temp & 0x02) << 6;
    temp8 = (temp & 0x01) << 3;
    h11 = temp1 | temp1 >> 1 | temp1 >> 2 | temp1 >> 3;
    h12 = temp2 | temp2 >> 1 | temp2 >> 2 | temp2 >> 3;
    h13 = temp3 | temp3 >> 1 | temp3 >> 2 | temp3 >> 3;
    h14 = temp4 | temp4 >> 1 | temp4 >> 2 | temp4 >> 3;
    h15 = temp5 | temp5 >> 1 | temp5 >> 2 | temp5 >> 3;
    h16 = temp6 | temp6 >> 1 | temp6 >> 2 | temp6 >> 3;
    h17 = temp7 | temp7 >> 1 | temp7 >> 2 | temp7 >> 3;
    h18 = temp8 | temp8 >> 1 | temp8 >> 2 | temp8 >> 3;
    d1 = h11 | h12;
    d2 = h13 | h14;
    d3 = h15 | h16;
    d4 = h17 | h18;

    Write_Data(d1);
    Write_Data(d2);
    Write_Data(d3);
    Write_Data(d4);
}


void OLED::lv_sh1122_flush_cb(lv_display_t * display, const lv_area_t * area, uint8_t * px_map)
{
	unsigned int xx,yy;	  
    uint8_t* buf = px_map;

    #if LV_COLOR_DEPTH == 1
        buf += 8;
        for(yy=0; yy<64; yy++)
        {
            Set_Row_Address(yy);
            Set_Column_Address(0x10,0x00);
            for(xx=0;xx<32;xx++)
            {
                uint8_t bv = *(buf++);
                Data_processing(bv);
            }
        }
    #elif LV_COLOR_DEPTH == 8
        for(yy=area->y1; yy<area->y2+1; yy++)
        {
            Set_Row_Address(yy);
            Set_Column_Address(0x10, area->x1 & 0xFF);
            for(xx=area->x1; xx<area->x2+1; xx+=2)
            {
                uint8_t bv1 = *(buf++) >> 4;
                uint8_t bv2 = *(buf++) >> 4;
                uint8_t bv = (bv1 << 4) | bv2;
                Write_Data(bv);
            }
        }    

    #else
        #pragma message "Unsupported color depth"
    #endif


    // Inform LVGL that flushing is complete so buffer can be modified again.
    lv_display_flush_ready(display);
}

//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//  Show Regular Pattern (Full Screen)
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
void OLED::show_pattern_mono(const uint8_t p[])
{
    unsigned char i, j;

    for (i = 0; i < 64; i++)
    {
        Set_Column_Address(0x10, 0x00); // Set higher & lower column Address
        Set_Row_Address(0);             //  Set Row-Address

        for (j = 0; j < 32; j++)
        {
            Data_processing(p[i * 32 + j]);
        }
    }
}



//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//  Show Regular Pattern (Full Screen)
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
void OLED::show_pattern_gray(const uint8_t p[])
{
	unsigned char i,j;	  

	for(i=0;i<64;i++)
	{
		Set_Column_Address(0x10,0x00);	   // Set higher & lower column Address
		Set_Row_Address(i);				   //  Set Row-Address 

		for(j=0;j<128;j++)
		{
			Write_Data(p[i*128+j]);
		}
	}
}
 

//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//  Show Regular Pattern (Full Screen)
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
void OLED::Fill_RAM(unsigned char Data)
{
	unsigned char i,j;	  

	for(i=0;i<64;i++)
	{
		Set_Column_Address(0x10,0x00);	   // Set higher & lower column Address
		Set_Row_Address(i);				   //  Set Row-Address 

		for(j=0;j<128;j++)
		{
			Write_Data(Data);
		}
	}
} 


//DISPLAY ASCII
void OLED::DrawSingleAscii(unsigned int x, unsigned int y, char *pAscii)
{
    unsigned char i;
    unsigned char str;
    unsigned int OffSet;

    OffSet = (*pAscii - 32)*16;

    for (i=0;i<16;i++)
    {
  		Set_Row_Address(y+i);
    	Set_Column_Address((0x10|(x>>4)),(0x0f&x));

        str = *(AsciiLib + OffSet + i);  


			Data_processing (str);             

    }
}

void OLED::DrawString(unsigned int x, unsigned int y, char *pStr)
{

    while(1)
    {
        if (*pStr == 0)
        {
            return;
        }
/*
        if (*pStr > 0x80)
        {
            DrawSingleHz(x, y, pStr);
            x += 8;
            pStr += 2;              
        }
        else
        {
        */
            DrawSingleAscii(x, y, pStr);
            x += 4;
            pStr += 1;              
        
        //}
    }   
}
